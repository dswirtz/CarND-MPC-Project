Reflection - Douglas Wirtz
June 25th, 2017

My implementation for this project used the quiz solutions from the lectures for inspiration. I first put the current state {px, py, psi, v} into a vector `currentstate` and the actuators {delta (steering_angle), a (throttle)} into a vector `actuators`. I used these two vectors in the globalKinematic function to predict the next state which is in a vector `next_state`. This vector's main purpose was to help with the latency. This idea was to predict the car's postion, and pass the `dt` variable into the MPC. I used the px, py, and psi from the `next_vector` variable to coefficients, `coeffs`, via `polyfit()`. Once the `coeffs` are calculated, I can calculate the `cte` and `epsi` to finish the state vector {px, py, psi, next_state.v, cte, epsi} for the MPC, `state << 0.0, 0.0, 0.0, next_state[3], cte, epsi`. After using `mpc.solve()`, I used the steering angle (`solution[6]`) and throttle values (`solution[7]`) to control the car. In addtion to those, I had vectors (`mpc.x_vals` and `mpc.y_vals`) set up to capture the predicted x and y values so I could map the waypoints on the track for visualization (green line). Then I used the vectors `nxt_xvals` and `nxt_yvals` calculated from the vehicle's current state to display a reference line on the track for visualization (yellow line).

When choosing `N` and `dt` values, I started with the values described in the solution to the mpc_to_line quiz (N = 25, dt = 0.05). With my model, those numbers proved to be out of control. I decided to reduce both numbers by about half (N = 10, dt = 0.03), and I instantly saw an improvement. Then I set N = 7 and dt = 0.3 and vehicle successfully completed a lap around the track, it still oscillated more than I wanted. I finalized on N = 6 and dt = 0.2. I found those numbers to have the best results.

I took a conservative approach when referring to the maximum throttle speed of my model. I set the max speed to 0.3 (1.0 = throttle at 100%). In a future implementation, I plan to implement penalties to the steering angles to hopefully smooth over the driving. In addition to the penalties, I would possibly implement conditionals to have the `mpc.solve()` return a different variation of predicted waypoints based on the previous waypoint (an attempt to make sure that two consecutive waypoints don't differ by a ridiculous amount) to help with smoothing. Finally, I'd like my future implementation to handle higher speeds with the same smoothness.
